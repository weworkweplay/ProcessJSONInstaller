<?php

require_once 'classes/Dependency.php';
require_once 'classes/Module.php';

/**
 * WWWP Installer Module
 *
 * A tool for common used setup processes
 *
 * How to use this to make your own Process module:
 *
 * 1. Rename the ProcessHello.module file to be Process[YourModuleName].module
 * 2. Change the class name to be Process[YourModuleName]
 * 3. Change the "const pageName" line at the top of the class to be your unique admin page name.
 * 4. Modify and add to this module to make it do what you want. 
 * 5. If your module needs its own CSS and/or JS files, rename those included to be the same as 
 *    your module name and modify them to do whatever you want. If your module does NOT need 
 *    CSS and/or JS files then delete them. 
 * 6. Change all the text here to describe your module and update the README.md file.
 * 7. Change the copyright line directly below to have your information.
 * 8. When ready, post your module to GitHub and to modules.processwire.com!
 *
 * Copyright 2013 by Pieter Beulque
 *
 *
 * ProcessWire 2.x
 * Copyright (C) 2012 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://processwire.com
 *
 */

class ProcessWWWPInstaller extends Process {

    /**
     * Return information about this module (required)
     *
     */
    public static function getModuleInfo() {
        return array(

            // Your module's title
            'title' => 'We Work We Play Installer',

            // A 1 sentence description of what your module does
            'summary' => 'Configure ProcessWire for common use cases',

            // Module version number: use 1 for 0.0.1 or 100 for 1.0.0, and so on
            'version' => 1,

            // Name of person who created this module (change to your name)
            'author' => 'Pieter Beulque',

            // URL to more info: change to your full modules.processwire.com URL (if available), or something else if you prefer
            'href' => 'http://modules.processwire.com/',

            // name of permission required of users to execute this Process (optional)
            'permission' => 'page-edit',
            );
    }

    /**
     * The name that will be used for the page this module creates
     *
     * It should be unique and the same (or similar) to the module name, but all lowercase.
     * It should not be the same as any other ProcessWire admin page name.
     *
     */
    const pageName = 'wwwp-installer';

    /**
     * Array containing all modules
     */
    protected $modules;

    /**
     * This is an optional initialization function called before any execute functions.
     *
     */
    public function init() {
        parent::init(); // required
        // List all your modules here
        $dir = wire('config')->paths->siteModules . get_class() . DIRECTORY_SEPARATOR . 'modules';
        $tmp = scandir($dir);
        $this->modules = array();

        foreach ($tmp as $file) {
            if (strpos($file, '.json') > 0) {
                $json = json_decode(file_get_contents($dir . DIRECTORY_SEPARATOR . $file));
                $this->modules[substr($file, 0, -5)] = WWWP\Module::createFromJSON($json);
            }
        }
    }

    /**
     * This function is executed when a page with your Process assigned is accessed.
     *
     * This can be seen as your main or index function. You'll probably want to replace
     * everything in this function.
     *
     */
    public function ___execute() {

        // $this->message("This is an example of a message");
        // $this->error("This is an example of a warning or error");
        // $this->message("This is an example of a debug notice, only shown when debug mode is on", Notice::debug); 

        // Modules table
        $table = wire('modules')->get("MarkupAdminDataTable");
        $url = wire('pages')->get("template=admin, name=" . self::pageName)->url;

        $table->headerRow(array(
            'name',
            'description',
            'action'
        ));

        foreach($this->modules as $key => $module) {
            $table->row(array(
                $module->name,
                $module->description,
                'Install' => 'install/' . $key
            ));
        }

        $table->action(array('Export site' => $url . 'export/'));

        $out = $table->render();
        return $out;
    }

    protected function addFolderToZip ($dir, $zip) {
        $actualDir = $dir;
        $dirName = substr($dir, strpos($dir, '/site/') + 1);

        if ($dh = opendir($actualDir)) {
            $zip->addEmptyDir($dirName);
            
            while (($file = readdir($dh)) !== false) {
                if ($file === '.' || $file === '..' || $file === '.DS_Store') continue;

                if(!is_file($actualDir . '/' . $file)) {
                    if ($file !== '.git') {
                        $this->addFolderToZip($actualDir . '/' . $file, $zip);
                    }
                    continue;
                }

                $zip->addFile($dir . '/' . $file, $dirName . '/' . $file);
            }
        }
    }

    protected function buildZipArchive() {
        $directories = array('site/install', 'site/modules', 'site/templates');
        $zip = new ZipArchive();

        $filePath = wire('config')->paths->root . 'site/assets/site-export-' . date('Y-m-d') . '.zip';

        if ($zip->open($filePath, ZipArchive::CREATE) === TRUE) {
            foreach ($directories as $dir) {
                $this->addFolderToZip(wire('config')->paths->root . $dir, $zip);
            }

            $zip->close();
        }

        return $filePath;
    }

    public function ___executeExport() {
        $export = wire('modules')->get('ProcessExportProfile');

        if (!$export->___executeRemove()) {
            $this->error('Something went wrong cleaning a leftover install');
        }

        if (!$export->___executeDump()) {
            $this->error('Something went wrong executing the database dump');
        }

        if (!$export->___executeCopy()) {
            $this->error('Something went wrong copying your files');
        }

        $filename = $_SERVER['HTTP_REFERER'];
        $filename = substr($filename, strpos($filename, '//') + 2);
        $filename = substr($filename, 0, strpos($filename, '/admin/'));
        $filename = str_replace(array('.', '/'), '-', $filename);

        $file = $this->buildZipArchive();

        header("Content-Type: application/zip");
        header("Content-Transfer-Encoding: Binary"); 
        header("Content-disposition: attachment; filename=\"export-" . $filename . "-" . date('Ymd') . ".zip" . "\""); 
        readfile($file);
    }

    public function installModule($name) {
        $module = $this->modules[$name];

        if (empty($module)) {
            throw new WireException();   
        }

        $module->install();
    }

    /**
     * Called when the URL is this module's page URL + "/install/?:name/"
     */
    public function ___executeInstall() {

        try {
            $this->installModule(wire('input')->urlSegment(2));
        } catch (WireException $e) {
            header('Location:' . wire('pages')->get("template=admin, name=" . self::pageName)->url);
        }

        $this->message('Succesfully installed or updated ' . $module->name);

        // set a new headline, replacing the one used by our page (optional)
        Wire::setFuel('processHeadline', 'Installing ' . $module->name);

        // add a breadcrumb that returns to our main page
        $this->breadcrumbs->add(new Breadcrumb('../', 'WWWP Installer'));

        $output = '';

        if (!empty($module->fields)) {
            $output .= '<h2>Created or edited fields</h2><ul class="wwwp-installer-list">';

            foreach ($module->fields as $field) {
                $output .= '<li>' . $field->name . ' - ' . $field->label . '</li>';
            }

            $output .= '</ul>';
        }

        if (!empty($module->templates)) {
            $output .= '<h2>Created or edited templates</h2><ul class="wwwp-installer-list">';

            foreach ($module->templates as $template) {
                $output .= '<li>' . $template->name . ' - ' . $template->label . '</li>';
            }

            $output .= '</ul>';
        }

        if (!empty($module->pages)) {
            $output .= '<h2>Created or edited pages</h2><ul class="wwwp-installer-list">';

            foreach ($module->pages as $page) {
                $output .= '<li>' . $page->name . '</li>';
            }

            $output .= '</ul>';
        }

        return $output . '<p><a href="../">Go Back</a></p>';
    }

    /**
     * Called only when your module is installed
     *
     * This version creates a new page with this Process module assigned. 
     *
     */
    public function ___install() {

        // create the page our module will be assigned to
        $page = new Page();
        $page->template = 'admin';
        $page->name = self::pageName;

        // installs to the admin "Setup" menu ... change as you see fit
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');
        $page->process = $this;

        // we will make the page title the same as our module title
        // but you can make it whatever you want
        $info = self::getModuleInfo();
        $page->title = $info['title'];

        // save the page
        $page->save();

        // tell the user we created this page
        $this->message("Created Page: {$page->path}");

        $this->installModule('config');

        $this->message('Ran config installation script');
    }

    /**
     * Called only when your module is uninstalled
     *
     * This should return the site to the same state it was in before the module was installed.
     *
     */
    public function ___uninstall() {

        // find the page we installed, locating it by the process field (which has the module ID)
        // it would probably be sufficient just to locate by name, but this is just to be extra sure.
        $moduleID = $this->modules->getModuleID($this);
        $page = $this->pages->get("template=admin, process=$moduleID, name=" . self::pageName);

        if($page->id) {
            // if we found the page, let the user know and delete it
            $this->message("Deleting Page: {$page->path}");
            $page->delete();
        }
    }
}